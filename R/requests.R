

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' c64 machine constants
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
machine <- list(
  mem_space = list(
    main    = 0L,
    drive8  = 1L,
    drive9  = 2L,
    drive10 = 3L,
    drive11 = 4L
  ), 
  bank = list(
    default = 0L, 
    cpu     = 0L, 
    ram     = 1L, 
    rom     = 2L, 
    io      = 3L, 
    cart    = 4L
  ),
  register = list(
    A    = list(id =  0L, bits =  8L), 
    X    = list(id =  1L, bits =  8L), 
    Y    = list(id =  2L, bits =  8L), 
    PC   = list(id =  3L, bits = 16L), 
    SP   = list(id =  4L, bits =  8L), 
    FL   = list(id =  5L, bits =  8L), 
    `00` = list(id = 55L, bits =  8L), 
    `01` = list(id = 56L, bits =  8L), 
    LIN  = list(id = 53L, bits = 16L), 
    CYC  = list(id = 54L, bits = 16L)
  ),
  register_idx = c(A = 0L, X = 1L, Y = 2L, PC = 3L, SP = 4L, FL = 5L, `00` = 55L, 
                   `01` = 56L, LIN = 53L, CYC = 54L)
)


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Parse out the header of a respose
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse_header <- function(bs) {
  stopifnot(bs$consume(1) == 2) # Start of response
  stopifnot(bs$consume(1) == 2) # Monitor Version
  
  list(
    n_bytes    = bs$consume_len4(), # bytes in payload of this response
    resp_type  = bs$consume(1),
    error_code = bs$consume(1),
    id         = bytes_to_int32(bs$consume(4))
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Named list of functions to parse response payload to R
#' @noRd
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse <- list()

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5 Responses
# 
# These responses are generated by many different commands, or by certain events. Events are generated with a # request ID of 0xffffffff, so that they can be easily distinguished from regular requests.
# 13.5.1 Invalid Response (0x00)
# 
# This response type is returned for errors.
# 
# Response type:
# 
# 0x00: MON_RESPONSE_INVALID
# 
# Response body:
# 
# Usually empty
# resp <- 0x00
# desc <- 'invalid'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x00']] <- function(bs, header) {
  error_msg <- switch(
    hex(header$error_code),
    "0x00" = "OK, everything worked ",
    "0x01" = "The object you are trying to get or set doesn't exist. ",
    "0x02" = "The memspace is invalid ",
    "0x80" = "Command length is not correct for this command ",
    "0x81" = "An invalid parameter value was present ",
    "0x82" = "The API version is not understood by the server ",
    "0x83" = "The command type is not understood by the server ",
    "0x8f" = "The command had parameter values that passed basic checks, but a general failure occurred",
    sprintf("Unknown error: ", error)
  )
  
  list(
    type = 'invalid',
    body = list(
      error = error_msg
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5.2 Checkpoint Response (0x11)
# 
# This response is generated by hitting a checkpoint, or by many of the 
# checkpoint commands.
# 
# See section 13.4.3 Checkpoint get (0x11).
# 
# See section 13.4.4 Checkpoint set (0x12).
# 
# See section 13.4.6 Checkpoint list (0x14).
# 
# Response type:
# 
# 0x11: MON_RESPONSE_CHECKPOINT_INFO
# 
# Response body:
# 
# byte 0-3: Checkpoint number
# byte 4: Currently hit?
#     >=0x01: true, 0x00: false 
# byte 5-6: start address
# byte 7-8: end address
# byte 9: stop when hit
#     >=0x01: true, 0x00: false 
# byte 10: enabled
#     >=0x01: true, 0x00: false 
# byte 11: CPU operation
#     0x01: load, 0x02: store, 0x04: exec 
# byte 12: temporary
#     Deletes the checkpoint after it has been hit once. This is similar to "until" command, but it will not # resume the emulator. 
# byte 13-16: hit count
# byte 17-20: ignore count
# byte 21: Has condition?
#     >=0x01: true, 0x00: false 
# byte 22: memspace
# 
#         0x00: main memory
#         0x01: drive 8
#         0x02: drive 9
#         0x03: drive 10
#         0x04: drive 11 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x11']] <- function(bs, header) {
  res <- list(
    checkpoint    = bs$consume_len4(),
    hit           = as.logical(bs$consume(1)),
    start         = bs$consume_len2(),
    end           = bs$consume_len2(),
    stop_when_hit = as.logical(bs$consume(1)),
    enabled       = as.logical(bs$consume(1)),
    cpu_op        = bs$consume(1),
    temporary     = as.logical(bs$consume(1)),
    hit_count     = bs$consume_len4(),
    ignore_count  = bs$consume_len4(),
    has_condition = bs$consume(1),
    mem_space     = bs$consume(1)
  )  
  
  list(
    type = 'checkpoint',
    body = res
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5.3 Register Response (0x31)
# 
# Response type:
# 
# 0x31: MON_RESPONSE_REGISTER_INFO
# 
# Response body:
# 
# byte 0-1: The count of the array items
# byte 2+: An array with items of structure:
# 
#     byte 0: Size of the item, excluding this byte
#     byte 1: ID of the register
#     byte 2-3: register value
#
# resp <- 0x31
# desc <- 'register'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x31']] <- function(bs, header) {
  # an array of structures
  n_elems <- bs$consume_len2()
  
  registers <- lapply(seq_len(n_elems), \(i) {
    len <- bs$consume(1) 
    stopifnot(len == 3)  # it's always 3.
    
    reg_id   <- bs$consume(1)
    reg_name <- names(machine$register_idx)[machine$register_idx == reg_id]
    reg_val <- bs$consume_len2()
    
    setNames(list(reg_val), reg_name)
  })
  
  list(
    type = 'register',
    body = unlist(registers, recursive = FALSE)
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5.4 JAM Response (0x61)
# 
# When the CPU jams
# 
# Response type:
# 
# 0x61: MON_RESPONSE_JAM
# 
# Response body:
# 
# byte 0-1: The current program counter position
#
# resp <- 0x61
# desc <- 'jam'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x61']] <- function(bs, header) {
  list(
    type = 'jam',
    body = list(
      pc = bs$consume_len2()
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5.5 Stopped Response (0x62)
# 
# When the machine stops for the monitor, either due to hitting a checkpoint or stepping.
# 
# Response type:
# 
# 0x62: MON_RESPONSE_STOPPED
# 
# Response body:
# 
# byte 0-1: The current program counter position
#
# resp <- 0x62
# desc <- 'stopped'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x62']] <- function(bs, header) {
  list(
    type = 'stopped',
    body = list(
      pc = bs$consume_len2()
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 13.5.6 Resumed Response (0x63)
# 
# When the machine resumes execution for any reason.
# 
# Response type:
# 
# 0x63: MON_RESPONSE_RESUMED
# 
# Response body:
# 
# byte 0-1: The current program counter position 
#
# resp <- 0x63
# desc <- 'resumed'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x63']] <- function(bs, header) {
  list(
    type = 'resumed',
    body = list(
      pc = bs$consume_len2()
    )
  )
}





#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Named list functions to generate raw byte vectors to be sent to VICE
#' 
#' Functions indexed by both their command code (e.g. "0x31") and 
#' by their description (e.g. "registers_get")
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req <- list()


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Assemble a VICE request
#' @param cmd integer representing the command
#' @param payload integer vector of bytes
#' @param id request id
#' @return raw vector of a complete VICE request
#' @noRd
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_assemble <- function(cmd, payload, id = cmd) {
  len <- length(payload)
  as.raw(c(
    # ---------------------- Header ------------------------------------
    0x02,                    # [0] Start of command
    0x02,                    # [1] APID version id
    int32_to_bytes(len)   ,  # [2-5] Length of payload (excludes header)
    int32_to_bytes(id)    ,  # [6-9] request id
    cmd ,                    # [10] command: 
    # ---------------------- Payload ------------------------------------
    payload
  ))
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Reads a chunk of memory from a start address to an end address (inclusive).
#' 
#' 13.4.1 Memory get (0x01)
#' 
#' 
#'
#' cmd  <- 0x01
#' 
#' @param start start address (integer)
#' @param end end address (integer)
#' @param mem_space memory space (integer). Default: 0 (main memory). Other
#'        acceptable values 1=drive8, 2=drive9, 3=drive10, 4=drive11
#' @param side_effects Should the read cause side effects? Default: FALSE
#' @param bank_id which bank you want. This is dependent on your machine. 
#'        If the memspace 
#'        selected doesn't support banks, this value is ignored.
#' 
#' @seealso [req_banks_available()]
#'
#' @return vector of raw bytes
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_memory_get <- function(start, end, mem_space = 0, side_effects = FALSE, 
                           bank_id = 0) {
  req_assemble(
    0x01,
    c(
      isTRUE(side_effects),   # [0]   side effects
      int16_to_bytes(start),  # [1-2] start address
      int16_to_bytes(end),    # [3-4] end address
      mem_space,              # [5]   memory space
      int16_to_bytes(bank_id) # [6-7] bank id
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# byte 0-1: The length of the memory segment. 
#           Will be zero for start 0x0000, end 0xffff.
# byte 2+: The memory at the address.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x01']] <- function(bs, header) {
  
  n_bytes <- bs$consume_len2()
  
  list(
    type = 'memory_get',
    body = list(
      bytes = bs$consume(n_bytes)
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Writes a chunk of memory from a start address to an end address (inclusive).
#' 
#' @inheritParams req_memory_get
#' @param bytes raw vector of bytes to be written to memory
#'
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_memory_set <- function(bytes, start, bank_id = 0, 
                                mem_space = machine$mem_space$main, 
                                side_effects = FALSE) {
  
  end <- start + length(bytes) - 1
  
  req_assemble(
    0x02,
    c(
      isTRUE(side_effects),    # [0]   Should the write cause side effects?
      int16_to_bytes(start),   # [1-2] Start address
      int16_to_bytes(end)  ,   # [3-4] End address
      mem_space,               # [5]   mamspace
      int16_to_bytes(bank_id), # [6-7]
      bytes                    # [8 - end]
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty respnse
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x02']] <- function(bs, header) {
  list(
    type = 'memory_set',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Gets any type of checkpoint. (break, watch, trace)
#' 
#' @param checkpoint number 32bit int.
#' 
#' @return a named list 
#' \describe{
#'   \item{checkpoint}{Checkpoint number}    
#'   \item{hit}{Currently hit? logical}
#'   \item{start}{Start address}
#'   \item{end}{End address}
#'   \item{stop_when_hit}{Stop when hit? Logical.}
#'   \item{enabled}{Logical.}
#'   \item{cpu_op}{CPU operatio: 1 = Load, 2 = Store, 4 = Exec}
#'   \item{temporary}{Deletes the checkpoint after it has been hit once. 
#'             This is similar to "until" command, but it will not 
#'             resume the emulator.}
#'   \item{hit_count}{Number of hits}
#'   \item{ignore_count}{Ignore count}
#'   \item{has_condition}{Has condition? Logical.}
#'   \item{mem_space}{Memory space.}
#' }
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_checkpoint_get <- function(checkpoint) {
  req_assemble(0x11, int32_to_bytes(checkpoint))
}
# resp_parse[['0x11']] # defined above

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Sets any type of checkpoint.
#'
#'  This combines the functionality of several 
#' textual commands (break, watch, # trace) into one, as they are all the 
#' same with only minor variations. To set conditions, see section 13.4.8 
#' Condition set (0x22) after executing this one.
#' 
#' @inheritParams req_memory_get
#' @param start start address
#' @param end end address
#' @param stop_when_hit logical. Default: TRUE
#' @param enabled logical. default: TRUE
#' @param cpu_op 1 = load. 2 = store. 4 = exec. devault: 1
#' @param temporary Deletes the checkpoint after it has been hit once. 
#'        This is similar to "until" command, but it will not resume the emulator.
#'        
#' @return checkpoint list. Samve as \code{req_checkpont_set}
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_checkpoint_set <- function(start, end, 
                                    stop_when_hit = TRUE, 
                                    enabled       = TRUE,  
                                    cpu_op        = 1, 
                                    temporary     = TRUE, 
                                    mem_space     = machine$mem_space$main) {
  req_assemble(
    0x12,
    c(
      int16_to_bytes(start),
      int16_to_bytes(end),
      isTRUE(stop_when_hit),
      isTRUE(enabled),
      cpu_op,
      isTRUE(temporary),
      mem_space
    )
  )
}

resp_parse[['0x12']] <- resp_parse[['0x11']]



#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Deletes any type of checkpoint. (break, watch, trace)
#' 
#' @inheritParams req_checkpoint_get
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_checkpoint_delete <- function(checkpoint) {
  req_assemble(0x13, int32_to_bytes(checkpoint))
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x13']] <- function(bs, header) {
  list(
    type = 'checkpoint_delete',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' List of checkpoints
#'
#' @return causes VICE to emit a series of responses (as would be returned
#' by a sequence of \code{req_checkpoint_get()}) followed by the actual
#' response body which is just a count of the total number of checkpoints
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_checkpoint_list <- function() {
  warning("The response to this function is not currently parsed correctly.
  Only the final count is captured, but not the list of checkpoint information")
  req_assemble(0x14, c())
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# List containing the total number of checkpoints.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x14']] <- function(bs, header) {
  list(
    type  = 'checkpoint_list',
    body  = list(
      count = bs$consume_len4()
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Checkpoint toggle
#' 
#' @inheritParams req_checkpoint_get
#' @param enabled Should checkpoint be enabled? logical.
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_checkpoint_toggle <- function(checkpoint, enabled) {
  req_assemble(0x15, c(int32_to_bytes(checkpoint), isTRUE(enabled)))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x15']] <- function(bs, header) {
  list(
    type = 'checkpoint_toggle',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Sets a condition on an existing checkpoint. It is not currently possible to 
#' retrieve conditions after setting them.
#' 
#' @inheritParams req_checkpoint_get
#' @param condition_expr Condition expression string. This is the same format 
#'        used on the command line.
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_condition_set <- function(checkpoint, condition_expr) {
  req_assemble(
    0x22,
    c(
      int32_to_bytes(checkpoint),
      nchar(condition_expr),
      utf8ToInt(condition_expr)
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x22']] <- function(bs, header) {
  list(
    type = 'checkpoint_set',
    body = list()
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Get details about the registers
#' 
#' @inheritParams req_memory_get
#' 
#' @return named integer vector where names are the register names.
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_registers_get <- function(mem_space = machine$mem_space$main) {
  req_assemble(0x31, c(mem_space))
}

# resp_parse[['0x31]] is defined above


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Set the register values
#' 
#' @inheritParams req_memory_get
#' @param ... name/value pairs specifying values for the named registers.
#'        e.g. \code{req_register_set(A = 12)}
#'         
#' @return named integer vector where names are the register names.
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_registers_set <- function(..., mem_space = machine$mem_space$main) {
  
  ll <- list(...)
  if (length(ll) == 0) stop("No named register values given as arguments")
  if (is.null(names(ll))) stop("Arguments must be named")
  
  reg_array <- c()
  for (i in seq_along(ll)) {
    nm  <- names(ll)[i]
    val <- ll[[i]]
    
    reg_id <- machine$register[[nm]]$id
    if (is.null(reg_id)) {
      stop("Unknown register: ", nm)
    }
    reg_array <- c(reg_array, c(3, reg_id, int16_to_bytes(val)))
  }
  
  # byte 0: memspace
  # byte 1-2: The count of the array items
  # byte 3+: An array with items of structure:
  # 
  #     byte 0: Size of the item, excluding this byte
  #     byte 1: ID of the register
  #     byte 2-3: register value
  req_assemble(
    0x32,
    c(
      mem_space,
      int16_to_bytes(length(ll)),
      reg_array
    )
  )
  
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Saves the machine state to a file.
#' 
#' @param filename filename to save machine state into
#' @param save_roms save ROMs to snapshot file?  Logical. default: FALSE
#' @param save_disks save disks to snapshot file. Logical. default: FALSE
#'
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_dump <- function(filename, save_roms = FALSE, save_disks = FALSE) {
  
  
  # byte 0: Save ROMs to snapshot file?
  #     >=0x01: true, 0x00: false 
  # byte 1: Save disks to snapshot file?
  #     >=0x01: true, 0x00: false 
  # byte 2: Length of filename
  # byte 3+: Filename
  #     The filename to save the snapshot to. 
  req_assemble(
    0x41,
    c(
      isTRUE(save_roms),  # [0]
      isTRUE(save_disks), # [1]
      nchar(filename),    # [2]
      utf8ToInt(filename) # [3 - end]
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x41']] <- function(bs, header) {
  list(
    type = 'dump',
    body = list()
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Loads the machine state from a file.
#'
#' @param filename filename containing dump of the machine state.
#' 
#' @return The current program counter position
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_undump <- function(filename) {
  
  # byte 0: Length of filename
  # byte 1+: Filename
  #     The filename to load the snapshot from. 
  req_assemble(
    0x42,
    c(
      nchar(filename),    # [0]
      utf8ToInt(filename) # [1 - end]
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# byte 0-1: The current program counter position
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x42']] <- function(bs, header) {
  list(
    type = 'undump',
    body = list(
      pc = bs$consume_len2()
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Get a resource value from the emulator. See section 6.1 Format of resource files.
#'
#' @param resource resource name. See \url{https://vice-emu.sourceforge.io/vice_6.html#SEC84}
#'
#' @return named list of 'type' of value (string or integer) and 'value'
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_resource_get <- function(resource) {
  # byte 0: Length of resource name
  # byte 1+: Resource name
  req_assemble(0x51, c(nchar(resource), utf8ToInt(resource)))
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# byte 0: Type of the resource
#     0x00: String, 0x01: Integer 
# byte 1: Length of the value
# byte 2+: The value
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x51']] <- function(bs, header) {
  
  type  <- bs$consume(1)
  len   <- bs$consume(1)
  value <- bs$consume(len)
  
  if (type == 0) {
    value <- intToUtf8(value)
  } else {
    if (len == 1) {
      value <- value
    } else if (len == 2) {
      value <- readBin(as.raw(c(value, 0, 0)), endian = 'little')
    } else if (len == 4) {
      value <- readBin(as.raw(value), endian = 'little')
    } else {
      stop("[0x51] resource_get. Bad value: ", deparse1(value))
    }
  }
  
  list(
    type = 'resource_get',
    body = list(
      type  = type,
      value = value
    )
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Set a resource value in the emulator. See section 6.1 Format of resource files.
#'
#' @inheritParams req_resource_get
#' @param value value to set. allowed: string or integer.
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_resource_set <- function(resource, value) {
  
  if (is.character(value)) {
    bytes <- utf8ToInt(value)
  } else {
    value <- as.integer(value)
    if (value > 65535) {
      bytes <- int32_to_bytes(value)
    } else if (value > 255) {
      bytes <- int16_to_bytes(value)
    } else {
      bytes <- value
    }
  }
  
  # 1 byte: Type of the resource value
  #     0x00: String, 0x01: Integer
  #     Strings will be interpreted if the destination is an Integer. 
  # 1 byte: Resource name length = (&name)
  # (*name) bytes: The resource name
  # 1 byte: Resource value length = (&value)
  # (*value) bytes: The resource value
  req_assemble(
    0x52,
    c(
      is.numeric(value),
      nchar(resource),
      utf8ToInt(resource),
      length(bytes),
      bytes
    )
  ) 
}


resp_parse[['0x52']] <- function(bs, header) {
  list(
    type = 'resource_set',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Step over a certain number of instructions.
#'
#' @param n number of instructions to jump over
#' @param sub1 Should subroutines count as a single instruction?
#' 
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_advance_instructions <- function(n, sub1 = TRUE) {
  # byte 0: Step over subroutines?
  #     Should subroutines count as a single instruction? 
  # byte 1-2: How many instructions to step over.
  req_assemble(0x71, c(isTRUE(sub1), n))    
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x71']] <- function(bs, header) {
  list(
    type = 'advance_instructions',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Add text to the keyboard buffer.
#' 
#' @param text PETSCII text
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_keyboard_feed <- function(text) {
  # byte 0: Length of text
  # byte 1+: The text, in PETSCII
  req_assemble(0x72, c(nchar(text), utf8ToInt(text)))    
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x72']] <- function(bs, header) {
  list(
    type = 'keyboard_feed',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Continues execution and returns to the monitor just after the next RTS or RTI is executed.
#' 
#' This command is the same as "return" in the text monitor.
#' 
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_execute_until_return <- function() {
  req_assemble(0x73, c())    
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x73']] <- function(bs, header) {
  list(
    type = 'execute_until_return',
    body = list()
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Get an empty response
#'
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_ping <- function() {
  req_assemble(0x81, c())
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x81']] <- function(bs, header) {
  list(
    type = 'ping',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Gives a listing of all the bank IDs for the running machine with their names.
#'
#' @return named list of bank IDs
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_banks_available <- function() {
  # byte 0-1: The count of the array items
  # byte 2+: An array with items of structure:
  req_assemble(0x82, c())    
}



#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     byte 0: Size of the item, excluding this byte
#     byte 1-2: bank ID
#     byte 3: Name length
#     byte 4+: Name
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x82']] <- function(bs, header) {
  n_elems <- bs$consume_len2()
  banks <- lapply(seq_len(n_elems), function(i) {
    len     <- bs$consume(1)
    bank_id <- bs$consume_len2()
    nm_len  <- bs$consume(1)
    nm      <- intToUtf8(bs$consume(nm_len))
    list(
      name = nm,
      id   = bank_id
    )
  })
  
  banks <- setNames(banks, lapply(banks, \(x) x$name))
  
  list(
    type = 'banks_available',
    body = list(
      banks = banks
    )
  )
  
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Gives a listing of all the registers for the running machine with their names.
#'
#' @inheritParams req_registers_get
#' @return named list of regiseters
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_registers_available <- function(mem_space = machine$mem_space$main) {
  req_assemble(0x83, c(mem_space))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# byte 0-1: The count of the array items
# byte 2+: An array with items of structure:
# 
#     byte 0: Size of the item, excluding this byte
#     byte 1: ID of the register
#     byte 2: Size of the register in bits
#     byte 3: Length of name
#     byte 4+: Name
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x83']] <- function(bs, header) {
  # an array of structures
  n_elems <- bs$consume_len2()
  
  registers <- lapply(seq_len(n_elems), \(i) {
    
    len        <-  bs$consume(1)
    id         <-  bs$consume(1)
    bits       <-  bs$consume(1)
    len_name   <-  bs$consume(1)
    name       <- bs$consume(len_name)
    name       <- intToUtf8(name)
    
    list(name = name, id = id, bits = bits)
  })
  
  registers <- setNames(
    registers,
    lapply(registers, \(x) x$name)
  )
  
  
  list(
    type = 'registers_available',
    body = list(
      registers = registers
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Gets the current screen in a requested bit format.
#'
#' This function returns a matrix which includes the screen capture including
#' a generous border on each side.
#' 
#' @return name list of metainformation including 'img' which contains the 
#'         colour indices at each memory location.
#' \describe{
#'   \item{len}{length of the fields before the display buffer}
#'   \item{dwidth, dheight}{Raw size of the returned matrix of pixels}
#'   \item{xoff, yoff}{Offset within the image to the actual screen pixels}
#'   \item{width, height}{dimensions of screen pixels starting at position (xoff, yoff)}
#'   \item{bpp}{bits per pixel}
#'   \item{img}{raw vector of colour at each pixel.}
#' }
#'
#' @export
#' @seealso [req_palette_get()]
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_display_get <- function() {
  # byte 0: USE VIC-II?
  #     Must be included, but ignored for all but the C128. If true, (>=0x01) the 
  #     screen returned will be from # the VIC-II. If false (0x00), it will be from the VDC. 
  # byte 1: Format
  #     0x00: Indexed, 8 bit
  req_assemble(0x84, c(TRUE, 0L))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 4 bytes: Length of the fields before the display buffer
# 2 bytes: Debug width of display buffer (uncropped)
#     The largest width the screen gets. 
# 2 bytes: Debug height of display buffer (uncropped)
#     The largest height the screen gets. 
# 2 bytes: X offset
#     X offset to the inner part of the screen. 
# 2 bytes: Y offset
#     Y offset to the inner part of the screen. 
# 2 bytes: Width of the inner part of the screen.
# 2 bytes: Height of the inner part of the screen.
# 1 byte: Bits per pixel of display buffer, 8
# 4 bytes: Length of display buffer = (&buffer)
# (*buffer) bytes: Display buffer data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x84']] <- function(bs, header) {
  res <- list(
    len     = bs$consume_len4(),
    dwidth  = bs$consume_len2(),
    dheight = bs$consume_len2(),
    xoff    = bs$consume_len2(),
    yoff    = bs$consume_len2(),
    width   = bs$consume_len2(),
    height  = bs$consume_len2(),
    bpp     = bs$consume(1),
    nbytes  = bs$consume_len4()
  )
  
  res$img <- bs$consume(res$nbytes)
  
  list(
    type = "display_get",
    body = res
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Get general information about VICE. Currently returns the versions.
#'
#' @return list with vice and SVN versions
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_vice_info <- function() {
  req_assemble(0x85, c())
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1 byte: Length of main version = (&main)
# (*main) bytes: Main version
#     In linear format. For example 0x03, 0x05, 0x00, 0x00 for 3.5.0.0 
# 1 byte: Length of SVN revision = (&rev)
# (*rev) bytes: SVN revision
#     In little endian format. Returns zero if it's not an SVN build. 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x85']] <- function(bs, header) {
  vice_len <- bs$consume(1)
  vice     <- bs$consume(vice_len)
  svn_len  <- bs$consume(1)
  svn      <- bs$consume(svn_len)
  
  list(
    type = 'vice_info',
    body = list(
      vice = vice,
      svn  = svn
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Get the colors in the current palette
#' 
#' @return character vector of colours
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_palette_get <- function() {
  # byte 0: USE VIC-II?
  #     Must be included, but ignored for all but the C128. If true, (>=0x01) the 
  #     screen returned will be from # the VIC-II. If false (0x00), it will be from the VDC. 
  req_assemble(0x91, c(TRUE))
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# byte 0-1: The number of palette items.
# byte 2+: An array with items of structure:
# 
#     byte 0: Size of the item, excluding this byte
#     byte 1: Red
#     byte 2: Green
#     byte 3: Blue
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0x91']] <- function(bs, header) {
  n_elems <- bs$consume_len2()
  
  r <- integer(n_elems)
  g <- integer(n_elems)
  b <- integer(n_elems)
  
  for (i in seq_len(n_elems)) {
    bs$consume(1)
    r[i] <- bs$consume(1)
    g[i] <- bs$consume(1)
    b[i] <- bs$consume(1)
  }
  
  list(
    type = 'palette_get',
    body = list(
      pal  = rgb(r, g, b, maxColorValue = 255)
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Set the simulated joyport value.
#'
#' @param port the port to set the value on
#' @param value value to set
#' 
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_joyport_set <- function(port, value) {
  # byte 0-1: The port to set the value on
  # byte 2-3: The value to set
  req_assemble(0xa2, c(int16_to_bytes(port), int16_to_bytes(value)))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xa2']] <- function(bs, header) {
  list(
    type = 'joyport_set',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#'Set the simulated userport value.
#'
#' @param value value to set
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_userport_set <- function(value) {
  # byte 0-1: The value to set
  req_assemble(0xb2, int16_to_bytes(value))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xb2']] <- function(bs, header) {
  list(
    type = 'userport_set',
    body = list()
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Exit the monitor until the next breakpoint.
#' @return empty response
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_exit <- function() {
  req_assemble(0xaa, c())
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xaa']] <- function(bs, header) {
  list(
    type = 'exit',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Quits VICE.
#' @return empty response
#' @export 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_quit <- function() {
  req_assemble(0xbb, c())
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty Response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xbb']] <- function(bs, header) {
  list(
    type = 'quit',
    body = list()
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Reset the system or a drive
#' 
#' @param hard_reset logical. default: TRUE
#' @param drive integer. 8-11. If set, then this drive is reset rather than 
#'        the main system.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_reset <- function(hard_reset = TRUE, drive = NULL) {
  #         0x00: Soft reset system
  #         0x01: Hard reset system
  #         0x08 - 0x0b: Reset drives 8 - 11 
  if (!is.null(drive)) {
    req_assemble(0xcc, drive)
  } else {
    req_assemble(0xcc, isTRUE(hard_reset))
  }
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xcc']] <- function(bs, header) {
  list(
    type = 'reset',
    body = list()
  )
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Load a program then return to the monitor
#' 
#' @param filename Name of file
#' @param file_idx If given a disk image, the index of the file to execute.
#'        Default: 0.
#' @param run_after_load logical. Default: TRUE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req_autostart <- function(filename, file_idx, run_after_load = TRUE) {
  # cmd  <- 0xdd
  # desc <- 'autostart'
  # byte 0: Run after loading?
  #     >=0x01: true, 0x00: false 
  # byte 1-2: File index
  #     The index of the file to execute, if a disk image. 0x00 is the default value. 
  # byte 3: Length of filename
  # byte 4+: Filename
  #     The filename to autoload. 
  req_assemble(
    0xdd, 
    c(
      isTRUE(run_after_load),
      int16_to_bytes(file_idx),
      nchar(filename),
      utf8ToInt(filename)
    )
  )
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Empty response
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse[['0xdd']] <- function(bs, header) {
  list(
    type = 'autostart',
    body = list()
  )
}






#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Parse a single response from the ByteStream
#' @param bs ByteStream object
#' @noRd
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse_single <- function(bs) {
  header <- resp_parse_header(bs)
  cmd    <- hex(header$resp_type)
  
  if (!cmd %in% names(resp_parse)) {
    warning("No parser yet for cmd: ", cmd)
    print(bs$vec[bs$idx:(length(bs$vec))])
    stop()
  }
  resp_body <- resp_parse[[cmd]](bs, header)
  c(header, resp_body)
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Parse all the response from the bytestream
#' @param bs ByteStream object
#' @noRd
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
resp_parse_multiple <- function(bs) {
  idx <- 1L
  response <- list()
  while (!bs$eos()) {
    # cat("Respose: ", idx, "\n")
    response[[idx]] <- resp_parse_single(bs)
    idx <- idx + 1L
  }
  response
}


req_set_id <- function(request, id) {
  request[7:10] <- as.raw(int32_to_bytes(id))
  request
}

req_get_id <- function(request) {
  id <- request[7:10]
  bytes_to_int32(id)
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' Deliver a request of raw bytes to the VICE binary monitor
#' 
#' @param request raw vector
#' @param parse_response default: TRUE. If FALSE then return raw vector
#' @param keep_raw should the raw bytes be returned as part of the parsed response?
#'        Default: FALSE
#' @param wait how long to wait before checking for the response to the request. 
#'        Default: 0.2s.  Different commands, networks and Operating Systems will have
#'        different requirements here.
#' @param host host to connect to. Default: "localhost"
#' @param port port on host to connect to. Default: 6502.  This is the default
#'        port set by VICE when running the binary monitor. 
#'
#' @importFrom stats runif
#' @return named list with parsed response or a raw vector (if \code{parse_response = FALSE})
#' @export
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
send_req <- function(request, parse_response = TRUE, keep_raw = FALSE, wait = 0.2,
                     host = "localhost", port = 6502) {
  stopifnot(is.raw(request))
  
  # Get the original ID. the lowest byte matches the request type
  orig_id <- req_get_id(request)
  
  id  <- as.integer(runif(1, 1, 2147483647))
  request <- req_set_id(request, id)
  req_get_id(request)
  
  socket <- socketConnection(host = host, port = port, open = "w+b")
  on.exit(close(socket))
  
  writeBin(request, socket)
  Sys.sleep(wait)
  resp_raw <- readBin(socket, "raw", n = 600000)
  resp_raw
  
  if (FALSE) {
    close(socket)
    resp_raw
  }
  
  if (!isTRUE(parse_response)) {
    return(resp_raw)
  }
  
  # Parse all the responses returned from VICE
  # There are nearly always multiple response packets for a single request packet.
  # e.g. 
  #   Response 1 = registers
  #   Response 2 = notification that VICE stopped
  #   Response 3 = actual response to query or error.
  bs <- ByteStream$new(resp_raw)
  responses <- resp_parse_multiple(bs)
  
  response <- Filter(\(r) r$id == id, responses)
  if (orig_id == 0x14) {
    # response to: req_checkpoint_list()
    # keep multiple responses as this command returns a sequence
    # of checkpoint return objects followed by a count.
    response[length(response)] <- NULL
  } else if (length(response) != 1) {
    warning("No matching response found for request")
    response <- responses[length(responses)]
  } else {
    response <- response[[1]]
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Keep the raw bytes for debugging
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (keep_raw) {
    response$raw <- resp_raw
  }  
  
  response
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Sort the 'req' functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
req <- req[sort(names(req))]



if (FALSE) {
  
  req_ping() |> send_req()
  
  prg <- as.raw(c(0x00, 0xc0, 0xee, 0x20, 0xd0, 0xee, 0x21, 0xd0, 0x4c, 
                  0x00, 0xc0))
  
  address <- bytes_to_int32(prg[1:2])
  code    <- prg[-c(1:2)]
  
  req_memory_set(code, address) |> send_req()
  
  req_keyboard_feed("SYS 49152\r") |> send_req()
}















